from abc import ABC, abstractmethod


"""import PySimpleGUI as sg


def create_window(theme):
    sg.set_options(font="Calibri 15", button_element_size=(1,1))
    sg.theme(theme)
    layer1 = [
        sg.Button("Iniciar", key="INICIAR"), sg.Input("", key="SPINNER")
    ],
    layer2 = [
        sg.Text("", key="OUTPUT")
    ]
    layout = [
        layer1,
        layer2
        ]
    return sg.Window("Probando", layout)

theme_menu = ["menu", ["LightGrey1", "dark", "DarkGrey8", "random"]]
window = create_window("LightGrey1")


output = ""
entrada2 = ""

while True:
    #Para cerrar la venta sin que de errores ni na
    event, values = window.read()
    if event == sg.WIN_CLOSED:
        break
    
    #Primera parte para el funcionamiento principal
    #Uso de operadores a traves de inputs y Spin
    if event == "INICIAR":
        output = ""
        fib = 1
        ant = 0
        for x in range(int(values["SPINNER"])):
            fib += ant
            output += f"{str(fib)}, "
            ant = fib
            window["OUTPUT"].update(output)






window.close()"""




"""
def generador_fibo():
    a,b = 0, 1
    while True:
        yield a
        a,b = b, a+b

secuencia = generador_fibo()
for i in range(10):
    print(next(secuencia))

lista = [1,2,3,4,5]

lista_cuadrados = [numero**2 for numero in lista]
print(lista_cuadrados)"""



"""
for x in range(19999):
    print("\033c"+"Loading\n"+round(x/19999*170)*"#")
    pass

#@property
def registro_llamadas(funcion):
    def wrapper(*args, **kwargs):
        resultado = funcion(*args, **kwargs)
        print(f"Llamada {funcion.__name__} con argumentos {args} y {kwargs}, resultado {resultado}")
        return resultado
    return wrapper

@registro_llamadas
def sumar(a,b):
    return a + b

resultado_suma = sumar(3,4)
"""

#Ejemplo usando el **kwargs
"""
def sumar(a,b,c,**kwargs):
    d = kwargs.get("d", )
    return a+b+c+d

print(sumar(2,3,4,d=32))"""






"""
class forma_geometrica(ABC):
    @abstractmethod
    def area(self):
        pass
    @abstractmethod
    def perimetro(self):
        pass

class rectangulo(forma_geometrica):
    def __init__(self, base, altura):
        self.base = base
        self.altura = altura
    
    def area(self):
        return self.base * self.altura
    
    def perimetro(self):
        return self.base * 2 + self.altura * 2

class circulo(forma_geometrica):
    def __init__(self, radio):
        self.radio = radio
    
    def area(self):
        return 3.14*self.radio**2
    def perimetro(self):
        return 2*3.14*self.radio

r = rectangulo(5,10)
print(r.area())
print(r.perimetro())
c = circulo(3)
print(c.area())
print(c.perimetro())
"""

"""
class RemoteControl(ABC):
    @abstractmethod
    def turn_on(self):
        pass
    @abstractmethod
    def turn_off(self):
        pass
    @abstractmethod
    def change_channel(self, channel):
        pass

class TV(RemoteControl):
    def __init__(self):
        self.is_on = False
        self.channel = 0
    
    def turn_on(self):
        self.is_on = True
        print("TV is on")
    def turn_off(self):
        self.is_on = False
        print("TV is off")
    def change_channel(self, channel):
        self.channel = channel
        print(f"Cambiando al canal {self.channel}")

class DVD(RemoteControl):
    def __init__(self):
        self.is_on = False
        self.channel = 0
    def turn_on(self):
        self.is_on = True
        print("TV is on")
    def turn_off(self):
        self.is_on = False
        print("TV is off")
    def change_channel(self, channel):
        self.channel = channel
        print(f"Cambiando al canal {self.channel}")

class RemoteControlDevice:
    def __init__(self, remote_control):
        self.remote_control = remote_control
    
    def turn_on(self):
        self.remote_control.turn_on()
    def turn_off(self):
        self.remote_control.turn_off()
    def change_channel(self, channel):
        self.remote_control.change_channel(channel)
    

tv = TV()
dvd = DVD()

tv_remote = RemoteControlDevice(tv)
dvd_remote = RemoteControlDevice(dvd)

tv_remote.turn_on()


class Compressor(ABC):
    @abstractmethod
    def intentar(self):
        pass

class zipo(Compressor):
    def empaquetar(self):
        print("Comprimido en un zip")


class rar(Compressor):
    def empaquetar(self):
        print("Comprimido en un rar")

class FabricadorDeEmpaquetados:
    def obtener_compressor(self, tipo_compressor):
        if tipo_compressor == "zip":
            return zipo()
        elif tipo_compressor == "rar":
            return rar
        else:
            return None
        

fabrica = FabricadorDeEmpaquetados()
archivozip = fabrica.obtener_compressor("zip")
archivozip.empaquetar()
"""









#finale bosse CLASIFICADOR DE SECUENCIAS: ADN, ARN, PROTEINAS
"""
class secuencia(ABC):
    @abstractmethod
    def clasificar(self):
        pass
    @abstractmethod
    def longitud(self):
        pass
    @abstractmethod
    def contarBases(self):
        pass
    @abstractmethod
    def contarAminoacidos(self):
        pass

class ADN(secuencia):
    def __init__ (self, cadena):
        self.cadena = cadena
    
    def clasificar(self):
        return "Es una secuencia de ADN"
    def longitud(self):
        return len(self.cadena)
    def contarBases(self):
        bases = {"A":0, "T":0, "C":0, "G":0}
        for base in self.cadena:
            bases[base] += 1
        return bases
    def contarAminoacidos(self):
        pass

class ARN(secuencia):
    def __init__(self,aminoacidos):
        self.aminoacidos = aminoacidos
    
    def clasificar(self):
        return "Es una secuencia de ARN"
    def longitud(self):
        return len(self.aminoacidos)
    def contarBases(self):
        pass
    def contarAminoacidos(self):
        aminoacidos = {"A":0, "R":0, "W":0}
        for amino in self.aminoacidos:
            aminoacidos[amino] += 1
        return aminoacidos
"""
#Si quisiesemos a침adir una tercera clase para las proteinas tendriamos que alterar nuestra clase abstracta con un contador de proteinas y a침adir esta nueva funci칩n
#A nuestras ya existentes clases de ADN y ARN con el termino "pass"




#Programaci칩n concurrente

import time
import threading

class coche:
    def rodar(self):
        print("Estoy rodando")
        for x in range(10):
            print(".")
            time.sleep(1)
    def girar(self):
        print("Giramos a la derecha 1 seg")
        print("--->")
        time.sleep(1)

coche1 = coche()

coche1.rodar()
for x in range(3):
    coche1.girar()

class rodar(threading.Thread):
    def __init__(self):
        super().__init__()
    def run(self):
        for x in range(5):
            print(".")
            time.sleep(1)

class girar(threading.Thread):
    def __init__(self):
        super().__init__()
    def turn(self):
        for x in range(5):
            print("-->")
